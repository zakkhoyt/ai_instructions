
<!-- 
Create a script (./configure_ai_instructions.zsh) to help install these ai instructions to a specific folder for a specific AI service. 

Terms:
* `repo_dir` - this repository's root directory (as cloned on the user's computer)
* `repo_instructions_dir` (`$repo_dir/instructions`) - this repository's directory where instructions are located
* `user_ai_dir` - A user level directory that will contains the "source of truth"
* `user_ai_instructions_dir` - a sub dir of `user_ai_dir` where the instructions are kept (`$user_ai_dir/instructions`)
* `target_dir` - the directory to configure AI instructions for.
* `<AI TODO>` - TODO task for AI agent to look up details on the internet


Args:
* --source-dir <dir>: (let's call this var `user_ai_dir`). 
  * If not passed as arg, check environment variable `Z2K_AI_DIR` before defaulting to `$HOME/.ai`

* --target-dir <path> : (let's call this var `target_dir`) Specify the directory to configure AI instructions for.
  * default: PWD
  * this must also be a root directory of a git repository. 
  * Ask git for the root dir then compare
    * log a warning if no git repository is found
    * log a warning if target_dir != git_root_dir
* --ai-platform <platform> : (let's call this var `ai_platform`) Specify the AI platform to configure instructions for.
  * valid options: 
    "copilot" aka "github-copilot", "github"
    "claude"
    "cursor"
    "coderabbit"
  * default: "copilot"
* --configure-type <copy | symlink> : (let's call this var `configure_type`) Specify whether to copy or symlink the instructions.
  * valid options: "copy", "symlink"
  * default: "symlink"

# Prepare
* init var `target_instructions_dir` from ai_platform
  * copilot: "$target_dir/.github/instructions"
  * claude: "$target_dir/.claude/settings.json"
  * cursor: "$target_dir/.cursor/rules/mobile.mdc"
  * coderabbit: <AI TODO>

* init var `ai_platform_instruction_file` from ai_platform
  * copilot: "$target_dir/.github/copilot-instructions.md"
  * claude: "$target_dir/.claude/settings.json"
  * cursor: "$target_dir/.cursor/rules/mobile.mdc"
  * coderabbit: <AI TODO>

* init var `ai_instruction_settings_file` from ai_platform
  * copilot: "$ai_platform_instruction_file"
  * cursor: "$ai_platform_instruction_file"
  * claude: "$target_dir/CLAUDE.md"
  * coderabbit: <AI TODO>
  


* create `$user_ai_instructions_dir` if needed
* Force copy this repository to `$user_ai_instructions_dir`  which will serve as the source of truth

* create `$target_instructions_dir` if needed
* read the contents of `$target_instructions_dir`. We will need a ways to compare existing instructions to those in `$repo_dir/instructions` to denote if they the source instructions have been updated since last linked. git diff? checksum?

* Present a menu to the user to select which instructions to "configure"
  * this menu should list reflect all files in `$user_ai_instructions_dir`
  * The menu should visually indicate which instructions are already installed in the target directory.
  * If configure_type == "copy", then the menu will need to indicate (for installed instructions) whether the source file has been updated since last copy.
  * the contents of the menu should be dynamically generated by listing all files in `$user_ai_instructions_dir`
  * The menu should visually indicate which instructions are already installed, but where the source file has been updated since last copy (if configure_type == "copy")

* For each selected instruction, "install" the file according to `configure_type`
    * if `configure_type` == "symlink", then create a symlink from `$user_ai_instructions_dir/<file>` to `$target_instructions_dir/<file>`
    * if `configure_type` == "copy", then copy the file from `$user_ai_instructions_dir/<file>` to `$target_instructions_dir/<file>` -->

---
<!-- 
# TODO / Additions

## Support development of this repo along side the target repo
* add a new cli flag: `--link-to-ai-dir`
* if set, then create a symlink to `$user_ai_dir` in `$target_dir1`
```zsh
# I think this is the correct command
ln -s $user_ai_dir $target_dir1
```
  

* [X] ~~*if `$target_dir1` contains a vscode-workspace file, modify it as if we had the VSCOde IDE open and "add folder to workspace"*~~ [2025-11-02]
* [X] ~~*if `$target_dir1` contains a .gitignore file, modify it to ignore the symlink created ^*~~ [2025-11-02]
* [ ] The above turns out to be redundant so let's break ^ into two args
1. --dev-link: create the symlink and update .gitignore
2. --dev-vscode: add folder to workspace
-->

--- 
<!-- 

when prsenting the menu to the user, where it is detected that some files have already been linked/copied

(like this)
```zsh
 1. [S] markdown-conventions.instructions.md
file_status=symlinked
status_indicator='[S]'
 2. [ ] swift-conventions.instructions.md
file_status=not_installed
status_indicator='[ ]'
 3. [S] zsh-conventions.instructions.md
```

pre-enter those already installed files into stdin (type it on behalf of the user, but dont' press enter)

EX:
In this case
```zsh
1 3
```

This way the user has only to press enter to update the files/links -->



---

<!-- # Synthesize and install a main `.github/copilot-instructions.md` (or equiv AI root instruction file)

When a user runs `scripts/configure_ai_instructions.zsh` to configure a repository with AI Instructions, the script does:
* `mkdir -p .github/instructions`, 
* Copy or linke the files from this repo's `instructions/**` to  `.github/instructions/**`
* [ ] However this excludes the main instuction file which for CoPilot is `.github/copilot-instructions.md`
* [ ] Should we create a committed copy in this repository? Where to store it?. 
    * [ ] Perhaps: `mkdir -p ai_platform/copilot; touch ai_platform/copilot/.github/copilot-instructions.md`
    * [ ] Perhaps: `mkdir -p ai_agent_files; mv instructions ai_agent_files; touch ai_agent_files/copilot-instructions.md`
* [ ] or should `scripts/configure_ai_instructions.zsh` create a cusomt one based on analyzing whwat's in the dest repo?   
* [ ] Dependiong on what we decide we might add base instructions for the otehr AI platforms

<!-- Here's one idea i had for solving this. 
Add a new arg flag, where when set the script will (after handling the instruction files):
* check if copilot cli is installed (prompt to install if not (wrap that in a function))
* use copilot cli to:
  * read the repository
  * read the instrutions that this script has already set up
  * set up `.github/copilot-instructions.md`  -->









<!-- 

# New flag to configure workspace settings for ai chat preferences 
* [ ] add an additional flag argument to `scripts/configure_ai_instructions.zsh`, say `--vscode-workspace-settings` 
  * (that's kind of a long name. Maybe something to play with `--dev-vscode`?)
* [ ] when present, and when the script does locate a `*.code-workspace` file, then populate some data into the `settings` dict of that file. 
  * [ ] See `./docs/todo/setup/json/vscode_ai_workspace_settings.json` where I've stored a copy of the data I;d like copied into the target file. 
    * [ ] Let's clean up this source file and relocate it to a more appropriate place.  
* [ ] This data should be added to the settings file, nto duplicated, and should also respect any key/values taht are pre-exising -->


<!-- # Improve `--dev-vscode`
This arg is working well as is (when running `scripts/configure_ai_instructions.zsh`), but it adds the `~/.ai` folder to the VSCodeWorkspace at the end (appends to the end of the json array). 
* [ ] Instead insert the `~/.ai` folder in lex order. This is usually going to be first element givne it's index. 
* [ ] This seems pretty simple to do. LMK if not. 
 -->

<!-- * [ ] New arg to add custom specs to:
  * [ ] `--dev-link`: Add additional `[--dev-link-name <dir_name>]` which has a default value of the last path component of `$user_ai_dir`. When creating the symlink, use this value for the directory name of the sym link. This allows the user to control what the sym link directory name is in their repo
  * [ ] `--dev-vscode`: : Add additional `[--dev-vscode-name <dir_name>]` which has a default value of the last path component of `$user_ai_dir`. When creating the folder name in VSCode, use this value for the folder name. This allows the user to control what the sym link directory name is in their repo -->





<!-- 

The script `scripts/configure_ai_instructions.zsh` is mostly working as expected. I've noticed some problems with the `--dev-vscode` arg. It's not quite working as expected. 

* should modify the first *.code-workspace file found. 
  * If none are found, print that none were found then move on without modifying the workspace
  * If multiple are found, prompt the user which to use
  * if only 1 found, modify that one. 
* When adding the dir to the workspace file, the `"path"` to `$user_ai_dir` should be absolute, if possible.  (in the example below it's relative: `"../../../../../.ai"`)
* The `"name"` property should be set along side `"path"`, and it should be set it should be set to the the last path compontent of `$user_ai_dir` is. In this example it should be `.ai`
* This script should be smart enough to detect if `user_ai_dir` has already been added to the workspace, then print as much and be done with this step. 

## Example 01
The workspace file `userscripts.code-workspace` was updated using `cd $HOME/code/repositories/z2k/github/userscripts && ~/.ai/scripts/configure_ai_instructions.zsh --dev-vscode --debug`

See a capture of the terminal I/O here: `scripts/.gitignored/bug01.log`

This is the diff of that at file after running the script

* Problem 1: The path to `$user_ai_dir` is completely wrong.
  * PWD is `$HOME/code/repositories/z2k/github/userscripts`
  * the relavite path to `$user_ai_dir` is `"path": "../../../../../.ai"`, not `.ai`. Like it's computing what should be `name` and putting it in `path`
* Problem 2: If the path property were correct, it should be absolute path (if possible)
  * Ideally: `$HOME/.ai`, falling back to `~/.ai`, falling back to `/Users/zakkhoyt/.ai`
* Problem 3: The name property is wrong. It should always be the leaf dir name of `path` (or `$user_ai_dir`). Never `"AI Documentation"`

```diff
   "folders": [
     {
       "path": "."
+    },
+    {
+      "path": ".ai",
+      "name": "AI Documentation"
     }
   ],
   "settings": {}
```
Ideal diff
```diff
   "folders": [
     {
       "path": "."
+    },
+    {
+      "path": "/Users/zakkhoyt/.ai",
+      "name": ".ai"
     }
   ],
   "settings": {}
```
 -->



# xcode mcp servvers

`scripts/configure_ai_instructions.zsh` now supports optional VSCode settings tailored for the Xcode MCP server.

* New flag `--mcp-xcode` forces installation of the MCP settings template without prompting.
* Outside of that flag, the script scans the target directory (after resolving git root) for `Package.swift`, `*.xcworkspace`, or `*.xcodeproj`.
  * When any of those artifacts are found, the user is prompted to merge the MCP settings.
  * Only the most recent `.code-workspace` file at the repo root is modified, and a backup is created before changes.
* Settings come from `vscode/xcode-mcpserver-workspace-settings.template.json`; the merge routine supports JSON comments so template annotations are preserved.
* The workspace merge uses the same jq-based deep-merge logic as the base AI template, so existing keys are preserved.


* [ ] Merge mcp.json files

## Other

* The base workspace template now lives at `vscode/ai-workspace-settings.template.json`; the old filename has been removed.
* Both the AI workspace template and the Xcode MCP template may include `//` and `/* */` comments. The merge step strips those comments via a small Python helper (with a sed fallback) before piping the JSON through `jq`.



## Refs
* [GitHub: Cameroncooke - Xcode Build Mcp](https://github.com/cameroncooke/XcodeBuildMCP?tab=readme-ov-file)
* [Install in VSCode](https://insiders.vscode.dev/redirect/mcp/install?name=XcodeBuildMCP&config=%7B%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22xcodebuildmcp%40latest%22%5D%7D)


![alt text](images/XcodeBuildMCP.png)

<!-- ps aux | grep -i mcp (or the specific target name) ensures the Xcode MCP process is alive; long-running background launchd jobs can be inspected with launchctl list | grep MCP.
If the server exposes a TCP socket, confirm it’s bound with lsof -nP -iTCP | grep <port> or target-specific netstat -an | grep <port>; successful LISTEN states indicate it’s ready.
Use whatever health endpoint/command the server exposes (often curl http://localhost:<port>/health or nc localhost <port>) to verify it responds with the expected banner or JSON.
Check recent logs (Console.app, log stream --predicate 'process == "XcodeMCP"', or the server’s own log file) for startup success messages and absence of crashes.
From Xcode, run the command that depends on the MCP server (e.g., initiate the custom build step or tool that uses it); if the integration succeeds without timeouts, the server is functioning. -->





# Dir Heirarchy

LMK what you think. Are there better ways to do this? Ask me questions, then let's agree on a plan.  -->

## Better support for other AI platforms. Both root instruction file and `instructions/**/*`
```zsh
ai_platforms/
├── copilot/
│   └── copilot-instructions.template.md
├── claude/
│   ├── .claude/
│   │   └── settings.template.json
│   └── CLAUDE.template.md
├── cursor/
│   └── .cursor/
│       └── rules/
│           └── mobile.template.mdc
└── coderabbit/
    └── .coderabbit.template.yml
```
